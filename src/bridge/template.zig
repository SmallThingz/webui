const std = @import("std");
const helpers = @import("runtime_helpers.zig");

pub const RpcFunctionMeta = struct {
    name: []const u8,
    arity: usize,
    ts_arg_signature: []const u8 = "",
    ts_return_type: []const u8 = "unknown",
};

pub const RenderOptions = struct {
    namespace: []const u8 = "webuiRpc",
    rpc_route: []const u8 = "/webui/rpc",
};

pub fn render(
    allocator: std.mem.Allocator,
    options: RenderOptions,
    functions: []const RpcFunctionMeta,
) ![]u8 {
    return renderWithRuntimeHelpers(allocator, options, functions, helpers.embedded_runtime_helpers_js);
}

pub fn renderForWrittenOutput(
    allocator: std.mem.Allocator,
    options: RenderOptions,
    functions: []const RpcFunctionMeta,
) ![]u8 {
    return renderWithRuntimeHelpers(allocator, options, functions, helpers.written_runtime_helpers_js);
}

fn renderWithRuntimeHelpers(
    allocator: std.mem.Allocator,
    options: RenderOptions,
    functions: []const RpcFunctionMeta,
    runtime_helpers_js: []const u8,
) ![]u8 {
    var out = std.array_list.Managed(u8).init(allocator);
    errdefer out.deinit();

    const writer = out.writer();
    try writer.writeAll("// Generated by tools/bridge_gen.zig\n");
    try writer.writeAll(runtime_helpers_js);
    try writer.writeAll("\nconst webuiRpcEndpoint = ");
    try writeJsonLiteral(allocator, writer, options.rpc_route);
    try writer.writeAll(";\n");
    try writer.writeAll("\nconst ");
    try writer.writeAll(options.namespace);
    try writer.writeAll(" = Object.freeze({\n");

    for (functions) |fn_meta| {
        try writer.writeAll("  ");
        try writer.writeAll(fn_meta.name);
        try writer.writeAll(": async (");

        var i: usize = 0;
        while (i < fn_meta.arity) : (i += 1) {
            if (i != 0) try writer.writeAll(", ");
            try writer.print("arg{d}", .{i});
        }

        try writer.writeAll(") => await webuiInvoke(webuiRpcEndpoint, ");
        try writeJsonLiteral(allocator, writer, fn_meta.name);
        try writer.writeAll(", [");
        i = 0;
        while (i < fn_meta.arity) : (i += 1) {
            if (i != 0) try writer.writeAll(", ");
            try writer.print("arg{d}", .{i});
        }
        try writer.writeAll("]),\n");
    }

    // Keep generated bridge JS usable from classic <script src="..."> loads.
    // Do not emit ESM `export` statements here: examples and legacy pages rely
    // on the global namespace binding being available immediately.
    try writer.writeAll("});\nif (typeof globalThis !== \"undefined\") { globalThis.");
    try writer.writeAll(options.namespace);
    try writer.writeAll(" = ");
    try writer.writeAll(options.namespace);
    try writer.writeAll("; }\n");

    return out.toOwnedSlice();
}

fn writeJsonLiteral(
    allocator: std.mem.Allocator,
    writer: anytype,
    value: anytype,
) !void {
    const encoded = try std.json.Stringify.valueAlloc(allocator, value, .{});
    defer allocator.free(encoded);
    try writer.writeAll(encoded);
}

pub fn renderComptime(comptime RpcStruct: type, comptime options: RenderOptions) []const u8 {
    const info = @typeInfo(RpcStruct);
    if (info != .@"struct") @compileError("RpcStruct must be a struct");

    comptime var out: []const u8 =
        "// Generated by tools/bridge_gen.zig\n" ++
        helpers.embedded_runtime_helpers_js ++
        "\nconst webuiRpcEndpoint = \"" ++ options.rpc_route ++ "\";\n" ++
        "\nconst " ++ options.namespace ++ " = Object.freeze({\n";

    inline for (info.@"struct".decls) |decl| {
        const value = @field(RpcStruct, decl.name);
        if (@typeInfo(@TypeOf(value)) != .@"fn") continue;

        const fn_info = @typeInfo(@TypeOf(value)).@"fn";
        const arity = fn_info.params.len;

        out = out ++ "  " ++ decl.name ++ ": async (";

        comptime var i: usize = 0;
        inline while (i < arity) : (i += 1) {
            if (i != 0) out = out ++ ", ";
            out = out ++ "arg" ++ std.fmt.comptimePrint("{d}", .{i});
        }

        out = out ++ ") => await webuiInvoke(webuiRpcEndpoint, \"" ++ decl.name ++ "\", [";

        i = 0;
        inline while (i < arity) : (i += 1) {
            if (i != 0) out = out ++ ", ";
            out = out ++ "arg" ++ std.fmt.comptimePrint("{d}", .{i});
        }

        out = out ++ "]),\n";
    }

    out = out ++ "});\nif (typeof globalThis !== \"undefined\") { globalThis." ++ options.namespace ++ " = " ++ options.namespace ++ "; }\n";
    return out;
}

pub fn renderTypeScriptDeclarations(
    allocator: std.mem.Allocator,
    options: RenderOptions,
    functions: []const RpcFunctionMeta,
) ![]u8 {
    var out = std.array_list.Managed(u8).init(allocator);
    errdefer out.deinit();

    const writer = out.writer();
    try writer.writeAll("// Generated by tools/bridge_gen.zig\n");
    try writer.writeAll("export interface WebuiRpcClient {\n");
    for (functions) |fn_meta| {
        try writer.writeAll("  ");
        try writer.writeAll(fn_meta.name);
        try writer.writeAll("(");
        if (fn_meta.ts_arg_signature.len > 0) {
            try writer.writeAll(fn_meta.ts_arg_signature);
        } else {
            var i: usize = 0;
            while (i < fn_meta.arity) : (i += 1) {
                if (i != 0) try writer.writeAll(", ");
                try writer.print("arg{d}: unknown", .{i});
            }
        }
        try writer.writeAll("): Promise<");
        if (fn_meta.ts_return_type.len > 0) {
            try writer.writeAll(fn_meta.ts_return_type);
        } else {
            try writer.writeAll("unknown");
        }
        try writer.writeAll(">;\n");
    }
    try writer.writeAll("}\n");
    try writer.writeAll("export declare const ");
    try writer.writeAll(options.namespace);
    try writer.writeAll(": WebuiRpcClient;\n");
    try writer.writeAll("declare global {\n");
    try writer.writeAll("  var ");
    try writer.writeAll(options.namespace);
    try writer.writeAll(": WebuiRpcClient;\n");
    try writer.writeAll("}\n");
    return out.toOwnedSlice();
}

pub fn renderTypeScriptDeclarationsComptime(comptime RpcStruct: type, comptime options: RenderOptions) []const u8 {
    const info = @typeInfo(RpcStruct);
    if (info != .@"struct") @compileError("RpcStruct must be a struct");

    comptime var out: []const u8 =
        "// Generated by tools/bridge_gen.zig\n" ++
        "export interface WebuiRpcClient {\n";

    inline for (info.@"struct".decls) |decl| {
        const value = @field(RpcStruct, decl.name);
        if (@typeInfo(@TypeOf(value)) != .@"fn") continue;
        out = out ++ "  " ++ decl.name ++ "(...args: unknown[]): Promise<unknown>;\n";
    }

    out = out ++
        "}\n" ++
        "export declare const " ++ options.namespace ++ ": WebuiRpcClient;\n" ++
        "declare global {\n" ++
        "  var " ++ options.namespace ++ ": WebuiRpcClient;\n" ++
        "}\n";
    return out;
}

pub const default_script =
    \\// Generated by tools/bridge_gen.zig
    \\const webuiRpcEndpoint = "/webui/rpc";
    \\const webuiRpc = Object.freeze({
    \\  ping: async () => await webuiInvoke(webuiRpcEndpoint, "ping", []),
    \\});
    \\if (typeof globalThis !== "undefined") { globalThis.webuiRpc = webuiRpc; }
;

test "default bridge script exports global namespace" {
    try std.testing.expect(std.mem.indexOf(u8, default_script, "globalThis.webuiRpc = webuiRpc") != null);
    try std.testing.expect(std.mem.indexOf(u8, default_script, "ping: async") != null);
}
